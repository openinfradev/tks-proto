// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.8
// source: info.proto

package tks_pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ClusterInfoServiceClient is the client API for ClusterInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterInfoServiceClient interface {
	// AddClusterInfo adds new cluster information
	AddClusterInfo(ctx context.Context, in *AddClusterInfoRequest, opts ...grpc.CallOption) (*IDResponse, error)
	// UpdateClusterConf updates the cluster configuration information
	UpdateClusterConf(ctx context.Context, in *UpdateClusterConfRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// GetCluster gets cluster info for the id of the cluster
	GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*GetClusterResponse, error)
	// GetClusters get every clusters on the mutlcluster
	GetClusters(ctx context.Context, in *GetClustersRequest, opts ...grpc.CallOption) (*GetClustersResponse, error)
	// UpdateClusterStatus update Status of the Cluster
	UpdateClusterStatus(ctx context.Context, in *UpdateClusterStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type clusterInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterInfoServiceClient(cc grpc.ClientConnInterface) ClusterInfoServiceClient {
	return &clusterInfoServiceClient{cc}
}

func (c *clusterInfoServiceClient) AddClusterInfo(ctx context.Context, in *AddClusterInfoRequest, opts ...grpc.CallOption) (*IDResponse, error) {
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.ClusterInfoService/AddClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterInfoServiceClient) UpdateClusterConf(ctx context.Context, in *UpdateClusterConfRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.ClusterInfoService/UpdateClusterConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterInfoServiceClient) GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*GetClusterResponse, error) {
	out := new(GetClusterResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.ClusterInfoService/GetCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterInfoServiceClient) GetClusters(ctx context.Context, in *GetClustersRequest, opts ...grpc.CallOption) (*GetClustersResponse, error) {
	out := new(GetClustersResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.ClusterInfoService/GetClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterInfoServiceClient) UpdateClusterStatus(ctx context.Context, in *UpdateClusterStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.ClusterInfoService/UpdateClusterStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterInfoServiceServer is the server API for ClusterInfoService service.
// All implementations must embed UnimplementedClusterInfoServiceServer
// for forward compatibility
type ClusterInfoServiceServer interface {
	// AddClusterInfo adds new cluster information
	AddClusterInfo(context.Context, *AddClusterInfoRequest) (*IDResponse, error)
	// UpdateClusterConf updates the cluster configuration information
	UpdateClusterConf(context.Context, *UpdateClusterConfRequest) (*SimpleResponse, error)
	// GetCluster gets cluster info for the id of the cluster
	GetCluster(context.Context, *GetClusterRequest) (*GetClusterResponse, error)
	// GetClusters get every clusters on the mutlcluster
	GetClusters(context.Context, *GetClustersRequest) (*GetClustersResponse, error)
	// UpdateClusterStatus update Status of the Cluster
	UpdateClusterStatus(context.Context, *UpdateClusterStatusRequest) (*SimpleResponse, error)
	mustEmbedUnimplementedClusterInfoServiceServer()
}

// UnimplementedClusterInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedClusterInfoServiceServer struct {
}

func (UnimplementedClusterInfoServiceServer) AddClusterInfo(context.Context, *AddClusterInfoRequest) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClusterInfo not implemented")
}
func (UnimplementedClusterInfoServiceServer) UpdateClusterConf(context.Context, *UpdateClusterConfRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterConf not implemented")
}
func (UnimplementedClusterInfoServiceServer) GetCluster(context.Context, *GetClusterRequest) (*GetClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCluster not implemented")
}
func (UnimplementedClusterInfoServiceServer) GetClusters(context.Context, *GetClustersRequest) (*GetClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusters not implemented")
}
func (UnimplementedClusterInfoServiceServer) UpdateClusterStatus(context.Context, *UpdateClusterStatusRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterStatus not implemented")
}
func (UnimplementedClusterInfoServiceServer) mustEmbedUnimplementedClusterInfoServiceServer() {}

// UnsafeClusterInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterInfoServiceServer will
// result in compilation errors.
type UnsafeClusterInfoServiceServer interface {
	mustEmbedUnimplementedClusterInfoServiceServer()
}

func RegisterClusterInfoServiceServer(s grpc.ServiceRegistrar, srv ClusterInfoServiceServer) {
	s.RegisterService(&ClusterInfoService_ServiceDesc, srv)
}

func _ClusterInfoService_AddClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInfoServiceServer).AddClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.ClusterInfoService/AddClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInfoServiceServer).AddClusterInfo(ctx, req.(*AddClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterInfoService_UpdateClusterConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInfoServiceServer).UpdateClusterConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.ClusterInfoService/UpdateClusterConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInfoServiceServer).UpdateClusterConf(ctx, req.(*UpdateClusterConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterInfoService_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInfoServiceServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.ClusterInfoService/GetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInfoServiceServer).GetCluster(ctx, req.(*GetClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterInfoService_GetClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInfoServiceServer).GetClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.ClusterInfoService/GetClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInfoServiceServer).GetClusters(ctx, req.(*GetClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterInfoService_UpdateClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInfoServiceServer).UpdateClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.ClusterInfoService/UpdateClusterStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInfoServiceServer).UpdateClusterStatus(ctx, req.(*UpdateClusterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterInfoService_ServiceDesc is the grpc.ServiceDesc for ClusterInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tks_pb.ClusterInfoService",
	HandlerType: (*ClusterInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddClusterInfo",
			Handler:    _ClusterInfoService_AddClusterInfo_Handler,
		},
		{
			MethodName: "UpdateClusterConf",
			Handler:    _ClusterInfoService_UpdateClusterConf_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _ClusterInfoService_GetCluster_Handler,
		},
		{
			MethodName: "GetClusters",
			Handler:    _ClusterInfoService_GetClusters_Handler,
		},
		{
			MethodName: "UpdateClusterStatus",
			Handler:    _ClusterInfoService_UpdateClusterStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "info.proto",
}

// CspInfoServiceClient is the client API for CspInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CspInfoServiceClient interface {
	// CreateCSPInfo create new CSP Info for the contract id.
	CreateCSPInfo(ctx context.Context, in *CreateCSPInfoRequest, opts ...grpc.CallOption) (*IDResponse, error)
	// GetCSPInfo returns an csp info by csp id.
	GetCSPInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetCSPInfoResponse, error)
	// GetCSPIDs returns all CSP ids.
	GetCSPIDs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IDsResponse, error)
	// GetCSPIDsByContractID returns the CSP ids by the contract id.
	GetCSPIDsByContractID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*IDsResponse, error)
	// UpdateCSPInfo updates an authentication config for CSP.
	UpdateCSPAuth(ctx context.Context, in *UpdateCSPAuthRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// GetCSPAuth returns an authentication info by csp id.
	GetCSPAuth(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetCSPAuthResponse, error)
}

type cspInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCspInfoServiceClient(cc grpc.ClientConnInterface) CspInfoServiceClient {
	return &cspInfoServiceClient{cc}
}

func (c *cspInfoServiceClient) CreateCSPInfo(ctx context.Context, in *CreateCSPInfoRequest, opts ...grpc.CallOption) (*IDResponse, error) {
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/CreateCSPInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cspInfoServiceClient) GetCSPInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetCSPInfoResponse, error) {
	out := new(GetCSPInfoResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/GetCSPInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cspInfoServiceClient) GetCSPIDs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IDsResponse, error) {
	out := new(IDsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/GetCSPIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cspInfoServiceClient) GetCSPIDsByContractID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*IDsResponse, error) {
	out := new(IDsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/GetCSPIDsByContractID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cspInfoServiceClient) UpdateCSPAuth(ctx context.Context, in *UpdateCSPAuthRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/UpdateCSPAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cspInfoServiceClient) GetCSPAuth(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetCSPAuthResponse, error) {
	out := new(GetCSPAuthResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.CspInfoService/GetCSPAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CspInfoServiceServer is the server API for CspInfoService service.
// All implementations must embed UnimplementedCspInfoServiceServer
// for forward compatibility
type CspInfoServiceServer interface {
	// CreateCSPInfo create new CSP Info for the contract id.
	CreateCSPInfo(context.Context, *CreateCSPInfoRequest) (*IDResponse, error)
	// GetCSPInfo returns an csp info by csp id.
	GetCSPInfo(context.Context, *IDRequest) (*GetCSPInfoResponse, error)
	// GetCSPIDs returns all CSP ids.
	GetCSPIDs(context.Context, *emptypb.Empty) (*IDsResponse, error)
	// GetCSPIDsByContractID returns the CSP ids by the contract id.
	GetCSPIDsByContractID(context.Context, *IDRequest) (*IDsResponse, error)
	// UpdateCSPInfo updates an authentication config for CSP.
	UpdateCSPAuth(context.Context, *UpdateCSPAuthRequest) (*SimpleResponse, error)
	// GetCSPAuth returns an authentication info by csp id.
	GetCSPAuth(context.Context, *IDRequest) (*GetCSPAuthResponse, error)
	mustEmbedUnimplementedCspInfoServiceServer()
}

// UnimplementedCspInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCspInfoServiceServer struct {
}

func (UnimplementedCspInfoServiceServer) CreateCSPInfo(context.Context, *CreateCSPInfoRequest) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCSPInfo not implemented")
}
func (UnimplementedCspInfoServiceServer) GetCSPInfo(context.Context, *IDRequest) (*GetCSPInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSPInfo not implemented")
}
func (UnimplementedCspInfoServiceServer) GetCSPIDs(context.Context, *emptypb.Empty) (*IDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSPIDs not implemented")
}
func (UnimplementedCspInfoServiceServer) GetCSPIDsByContractID(context.Context, *IDRequest) (*IDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSPIDsByContractID not implemented")
}
func (UnimplementedCspInfoServiceServer) UpdateCSPAuth(context.Context, *UpdateCSPAuthRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCSPAuth not implemented")
}
func (UnimplementedCspInfoServiceServer) GetCSPAuth(context.Context, *IDRequest) (*GetCSPAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCSPAuth not implemented")
}
func (UnimplementedCspInfoServiceServer) mustEmbedUnimplementedCspInfoServiceServer() {}

// UnsafeCspInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CspInfoServiceServer will
// result in compilation errors.
type UnsafeCspInfoServiceServer interface {
	mustEmbedUnimplementedCspInfoServiceServer()
}

func RegisterCspInfoServiceServer(s grpc.ServiceRegistrar, srv CspInfoServiceServer) {
	s.RegisterService(&CspInfoService_ServiceDesc, srv)
}

func _CspInfoService_CreateCSPInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCSPInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).CreateCSPInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/CreateCSPInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).CreateCSPInfo(ctx, req.(*CreateCSPInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CspInfoService_GetCSPInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).GetCSPInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/GetCSPInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).GetCSPInfo(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CspInfoService_GetCSPIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).GetCSPIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/GetCSPIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).GetCSPIDs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CspInfoService_GetCSPIDsByContractID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).GetCSPIDsByContractID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/GetCSPIDsByContractID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).GetCSPIDsByContractID(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CspInfoService_UpdateCSPAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCSPAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).UpdateCSPAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/UpdateCSPAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).UpdateCSPAuth(ctx, req.(*UpdateCSPAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CspInfoService_GetCSPAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CspInfoServiceServer).GetCSPAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.CspInfoService/GetCSPAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CspInfoServiceServer).GetCSPAuth(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CspInfoService_ServiceDesc is the grpc.ServiceDesc for CspInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CspInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tks_pb.CspInfoService",
	HandlerType: (*CspInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCSPInfo",
			Handler:    _CspInfoService_CreateCSPInfo_Handler,
		},
		{
			MethodName: "GetCSPInfo",
			Handler:    _CspInfoService_GetCSPInfo_Handler,
		},
		{
			MethodName: "GetCSPIDs",
			Handler:    _CspInfoService_GetCSPIDs_Handler,
		},
		{
			MethodName: "GetCSPIDsByContractID",
			Handler:    _CspInfoService_GetCSPIDsByContractID_Handler,
		},
		{
			MethodName: "UpdateCSPAuth",
			Handler:    _CspInfoService_UpdateCSPAuth_Handler,
		},
		{
			MethodName: "GetCSPAuth",
			Handler:    _CspInfoService_GetCSPAuth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "info.proto",
}

// AppInfoServiceClient is the client API for AppInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppInfoServiceClient interface {
	// CreateAppGroup creates a new application group.
	CreateAppGroup(ctx context.Context, in *CreateAppGroupRequest, opts ...grpc.CallOption) (*IDResponse, error)
	// GetAppGroupsByClusterID gets an array of app infos By the clusterID
	GetAppGroupsByClusterID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetAppGroupsResponse, error)
	// GetAppGroups gets an array of app infos by name & type in the cluster
	GetAppGroups(ctx context.Context, in *GetAppGroupsRequest, opts ...grpc.CallOption) (*GetAppGroupsResponse, error)
	// GetAppGroup gets an application group by application group ID
	GetAppGroup(ctx context.Context, in *GetAppGroupRequest, opts ...grpc.CallOption) (*GetAppGroupResponse, error)
	// UpdateAppGroupStatus updates a status of an application group
	UpdateAppGroupStatus(ctx context.Context, in *UpdateAppGroupStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// DeleteAppGroup deletes an app group.
	DeleteAppGroup(ctx context.Context, in *DeleteAppGroupRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// GetAppsByClusterID gets applications by application group id.
	GetAppsByAppGroupID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetAppsResponse, error)
	// GetApps gets applications by application type and application id.
	GetApps(ctx context.Context, in *GetAppsRequest, opts ...grpc.CallOption) (*GetAppsResponse, error)
	// UpdateApp updates application data.
	UpdateApp(ctx context.Context, in *UpdateAppRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type appInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAppInfoServiceClient(cc grpc.ClientConnInterface) AppInfoServiceClient {
	return &appInfoServiceClient{cc}
}

func (c *appInfoServiceClient) CreateAppGroup(ctx context.Context, in *CreateAppGroupRequest, opts ...grpc.CallOption) (*IDResponse, error) {
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/CreateAppGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) GetAppGroupsByClusterID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetAppGroupsResponse, error) {
	out := new(GetAppGroupsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/GetAppGroupsByClusterID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) GetAppGroups(ctx context.Context, in *GetAppGroupsRequest, opts ...grpc.CallOption) (*GetAppGroupsResponse, error) {
	out := new(GetAppGroupsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/GetAppGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) GetAppGroup(ctx context.Context, in *GetAppGroupRequest, opts ...grpc.CallOption) (*GetAppGroupResponse, error) {
	out := new(GetAppGroupResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/GetAppGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) UpdateAppGroupStatus(ctx context.Context, in *UpdateAppGroupStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/UpdateAppGroupStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) DeleteAppGroup(ctx context.Context, in *DeleteAppGroupRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/DeleteAppGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) GetAppsByAppGroupID(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetAppsResponse, error) {
	out := new(GetAppsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/GetAppsByAppGroupID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) GetApps(ctx context.Context, in *GetAppsRequest, opts ...grpc.CallOption) (*GetAppsResponse, error) {
	out := new(GetAppsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/GetApps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInfoServiceClient) UpdateApp(ctx context.Context, in *UpdateAppRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppInfoService/UpdateApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppInfoServiceServer is the server API for AppInfoService service.
// All implementations must embed UnimplementedAppInfoServiceServer
// for forward compatibility
type AppInfoServiceServer interface {
	// CreateAppGroup creates a new application group.
	CreateAppGroup(context.Context, *CreateAppGroupRequest) (*IDResponse, error)
	// GetAppGroupsByClusterID gets an array of app infos By the clusterID
	GetAppGroupsByClusterID(context.Context, *IDRequest) (*GetAppGroupsResponse, error)
	// GetAppGroups gets an array of app infos by name & type in the cluster
	GetAppGroups(context.Context, *GetAppGroupsRequest) (*GetAppGroupsResponse, error)
	// GetAppGroup gets an application group by application group ID
	GetAppGroup(context.Context, *GetAppGroupRequest) (*GetAppGroupResponse, error)
	// UpdateAppGroupStatus updates a status of an application group
	UpdateAppGroupStatus(context.Context, *UpdateAppGroupStatusRequest) (*SimpleResponse, error)
	// DeleteAppGroup deletes an app group.
	DeleteAppGroup(context.Context, *DeleteAppGroupRequest) (*SimpleResponse, error)
	// GetAppsByClusterID gets applications by application group id.
	GetAppsByAppGroupID(context.Context, *IDRequest) (*GetAppsResponse, error)
	// GetApps gets applications by application type and application id.
	GetApps(context.Context, *GetAppsRequest) (*GetAppsResponse, error)
	// UpdateApp updates application data.
	UpdateApp(context.Context, *UpdateAppRequest) (*SimpleResponse, error)
	mustEmbedUnimplementedAppInfoServiceServer()
}

// UnimplementedAppInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAppInfoServiceServer struct {
}

func (UnimplementedAppInfoServiceServer) CreateAppGroup(context.Context, *CreateAppGroupRequest) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppGroup not implemented")
}
func (UnimplementedAppInfoServiceServer) GetAppGroupsByClusterID(context.Context, *IDRequest) (*GetAppGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppGroupsByClusterID not implemented")
}
func (UnimplementedAppInfoServiceServer) GetAppGroups(context.Context, *GetAppGroupsRequest) (*GetAppGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppGroups not implemented")
}
func (UnimplementedAppInfoServiceServer) GetAppGroup(context.Context, *GetAppGroupRequest) (*GetAppGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppGroup not implemented")
}
func (UnimplementedAppInfoServiceServer) UpdateAppGroupStatus(context.Context, *UpdateAppGroupStatusRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppGroupStatus not implemented")
}
func (UnimplementedAppInfoServiceServer) DeleteAppGroup(context.Context, *DeleteAppGroupRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAppGroup not implemented")
}
func (UnimplementedAppInfoServiceServer) GetAppsByAppGroupID(context.Context, *IDRequest) (*GetAppsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppsByAppGroupID not implemented")
}
func (UnimplementedAppInfoServiceServer) GetApps(context.Context, *GetAppsRequest) (*GetAppsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApps not implemented")
}
func (UnimplementedAppInfoServiceServer) UpdateApp(context.Context, *UpdateAppRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApp not implemented")
}
func (UnimplementedAppInfoServiceServer) mustEmbedUnimplementedAppInfoServiceServer() {}

// UnsafeAppInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppInfoServiceServer will
// result in compilation errors.
type UnsafeAppInfoServiceServer interface {
	mustEmbedUnimplementedAppInfoServiceServer()
}

func RegisterAppInfoServiceServer(s grpc.ServiceRegistrar, srv AppInfoServiceServer) {
	s.RegisterService(&AppInfoService_ServiceDesc, srv)
}

func _AppInfoService_CreateAppGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).CreateAppGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/CreateAppGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).CreateAppGroup(ctx, req.(*CreateAppGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_GetAppGroupsByClusterID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).GetAppGroupsByClusterID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/GetAppGroupsByClusterID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).GetAppGroupsByClusterID(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_GetAppGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).GetAppGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/GetAppGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).GetAppGroups(ctx, req.(*GetAppGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_GetAppGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).GetAppGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/GetAppGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).GetAppGroup(ctx, req.(*GetAppGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_UpdateAppGroupStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppGroupStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).UpdateAppGroupStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/UpdateAppGroupStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).UpdateAppGroupStatus(ctx, req.(*UpdateAppGroupStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_DeleteAppGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAppGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).DeleteAppGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/DeleteAppGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).DeleteAppGroup(ctx, req.(*DeleteAppGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_GetAppsByAppGroupID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).GetAppsByAppGroupID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/GetAppsByAppGroupID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).GetAppsByAppGroupID(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_GetApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).GetApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/GetApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).GetApps(ctx, req.(*GetAppsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInfoService_UpdateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInfoServiceServer).UpdateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppInfoService/UpdateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInfoServiceServer).UpdateApp(ctx, req.(*UpdateAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AppInfoService_ServiceDesc is the grpc.ServiceDesc for AppInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tks_pb.AppInfoService",
	HandlerType: (*AppInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAppGroup",
			Handler:    _AppInfoService_CreateAppGroup_Handler,
		},
		{
			MethodName: "GetAppGroupsByClusterID",
			Handler:    _AppInfoService_GetAppGroupsByClusterID_Handler,
		},
		{
			MethodName: "GetAppGroups",
			Handler:    _AppInfoService_GetAppGroups_Handler,
		},
		{
			MethodName: "GetAppGroup",
			Handler:    _AppInfoService_GetAppGroup_Handler,
		},
		{
			MethodName: "UpdateAppGroupStatus",
			Handler:    _AppInfoService_UpdateAppGroupStatus_Handler,
		},
		{
			MethodName: "DeleteAppGroup",
			Handler:    _AppInfoService_DeleteAppGroup_Handler,
		},
		{
			MethodName: "GetAppsByAppGroupID",
			Handler:    _AppInfoService_GetAppsByAppGroupID_Handler,
		},
		{
			MethodName: "GetApps",
			Handler:    _AppInfoService_GetApps_Handler,
		},
		{
			MethodName: "UpdateApp",
			Handler:    _AppInfoService_UpdateApp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "info.proto",
}

// AppServeAppServiceClient is the client API for AppServeAppService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppServeAppServiceClient interface {
	CreateAppServeApp(ctx context.Context, in *CreateAppServeAppRequest, opts ...grpc.CallOption) (*IDResponse, error)
	UpdateAppServeApp(ctx context.Context, in *UpdateAppServeAppRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	GetAppServeApp(ctx context.Context, in *GetAppServeAppRequest, opts ...grpc.CallOption) (*GetAppServeAppResponse, error)
	GetAppServeApps(ctx context.Context, in *GetAppServeAppsRequest, opts ...grpc.CallOption) (*GetAppServeAppsResponse, error)
	UpdateAppServeAppStatus(ctx context.Context, in *UpdateAppServeAppStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	UpdateAppServeAppEndpoint(ctx context.Context, in *UpdateAppServeAppEndpointRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type appServeAppServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAppServeAppServiceClient(cc grpc.ClientConnInterface) AppServeAppServiceClient {
	return &appServeAppServiceClient{cc}
}

func (c *appServeAppServiceClient) CreateAppServeApp(ctx context.Context, in *CreateAppServeAppRequest, opts ...grpc.CallOption) (*IDResponse, error) {
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/CreateAppServeApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appServeAppServiceClient) UpdateAppServeApp(ctx context.Context, in *UpdateAppServeAppRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/UpdateAppServeApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appServeAppServiceClient) GetAppServeApp(ctx context.Context, in *GetAppServeAppRequest, opts ...grpc.CallOption) (*GetAppServeAppResponse, error) {
	out := new(GetAppServeAppResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/GetAppServeApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appServeAppServiceClient) GetAppServeApps(ctx context.Context, in *GetAppServeAppsRequest, opts ...grpc.CallOption) (*GetAppServeAppsResponse, error) {
	out := new(GetAppServeAppsResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/GetAppServeApps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appServeAppServiceClient) UpdateAppServeAppStatus(ctx context.Context, in *UpdateAppServeAppStatusRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/UpdateAppServeAppStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appServeAppServiceClient) UpdateAppServeAppEndpoint(ctx context.Context, in *UpdateAppServeAppEndpointRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.AppServeAppService/UpdateAppServeAppEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppServeAppServiceServer is the server API for AppServeAppService service.
// All implementations must embed UnimplementedAppServeAppServiceServer
// for forward compatibility
type AppServeAppServiceServer interface {
	CreateAppServeApp(context.Context, *CreateAppServeAppRequest) (*IDResponse, error)
	UpdateAppServeApp(context.Context, *UpdateAppServeAppRequest) (*SimpleResponse, error)
	GetAppServeApp(context.Context, *GetAppServeAppRequest) (*GetAppServeAppResponse, error)
	GetAppServeApps(context.Context, *GetAppServeAppsRequest) (*GetAppServeAppsResponse, error)
	UpdateAppServeAppStatus(context.Context, *UpdateAppServeAppStatusRequest) (*SimpleResponse, error)
	UpdateAppServeAppEndpoint(context.Context, *UpdateAppServeAppEndpointRequest) (*SimpleResponse, error)
	mustEmbedUnimplementedAppServeAppServiceServer()
}

// UnimplementedAppServeAppServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAppServeAppServiceServer struct {
}

func (UnimplementedAppServeAppServiceServer) CreateAppServeApp(context.Context, *CreateAppServeAppRequest) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppServeApp not implemented")
}
func (UnimplementedAppServeAppServiceServer) UpdateAppServeApp(context.Context, *UpdateAppServeAppRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppServeApp not implemented")
}
func (UnimplementedAppServeAppServiceServer) GetAppServeApp(context.Context, *GetAppServeAppRequest) (*GetAppServeAppResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppServeApp not implemented")
}
func (UnimplementedAppServeAppServiceServer) GetAppServeApps(context.Context, *GetAppServeAppsRequest) (*GetAppServeAppsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppServeApps not implemented")
}
func (UnimplementedAppServeAppServiceServer) UpdateAppServeAppStatus(context.Context, *UpdateAppServeAppStatusRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppServeAppStatus not implemented")
}
func (UnimplementedAppServeAppServiceServer) UpdateAppServeAppEndpoint(context.Context, *UpdateAppServeAppEndpointRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppServeAppEndpoint not implemented")
}
func (UnimplementedAppServeAppServiceServer) mustEmbedUnimplementedAppServeAppServiceServer() {}

// UnsafeAppServeAppServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppServeAppServiceServer will
// result in compilation errors.
type UnsafeAppServeAppServiceServer interface {
	mustEmbedUnimplementedAppServeAppServiceServer()
}

func RegisterAppServeAppServiceServer(s grpc.ServiceRegistrar, srv AppServeAppServiceServer) {
	s.RegisterService(&AppServeAppService_ServiceDesc, srv)
}

func _AppServeAppService_CreateAppServeApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppServeAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).CreateAppServeApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/CreateAppServeApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).CreateAppServeApp(ctx, req.(*CreateAppServeAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppServeAppService_UpdateAppServeApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppServeAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).UpdateAppServeApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/UpdateAppServeApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).UpdateAppServeApp(ctx, req.(*UpdateAppServeAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppServeAppService_GetAppServeApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppServeAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).GetAppServeApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/GetAppServeApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).GetAppServeApp(ctx, req.(*GetAppServeAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppServeAppService_GetAppServeApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppServeAppsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).GetAppServeApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/GetAppServeApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).GetAppServeApps(ctx, req.(*GetAppServeAppsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppServeAppService_UpdateAppServeAppStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppServeAppStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).UpdateAppServeAppStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/UpdateAppServeAppStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).UpdateAppServeAppStatus(ctx, req.(*UpdateAppServeAppStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppServeAppService_UpdateAppServeAppEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppServeAppEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServeAppServiceServer).UpdateAppServeAppEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.AppServeAppService/UpdateAppServeAppEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServeAppServiceServer).UpdateAppServeAppEndpoint(ctx, req.(*UpdateAppServeAppEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AppServeAppService_ServiceDesc is the grpc.ServiceDesc for AppServeAppService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppServeAppService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tks_pb.AppServeAppService",
	HandlerType: (*AppServeAppServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAppServeApp",
			Handler:    _AppServeAppService_CreateAppServeApp_Handler,
		},
		{
			MethodName: "UpdateAppServeApp",
			Handler:    _AppServeAppService_UpdateAppServeApp_Handler,
		},
		{
			MethodName: "GetAppServeApp",
			Handler:    _AppServeAppService_GetAppServeApp_Handler,
		},
		{
			MethodName: "GetAppServeApps",
			Handler:    _AppServeAppService_GetAppServeApps_Handler,
		},
		{
			MethodName: "UpdateAppServeAppStatus",
			Handler:    _AppServeAppService_UpdateAppServeAppStatus_Handler,
		},
		{
			MethodName: "UpdateAppServeAppEndpoint",
			Handler:    _AppServeAppService_UpdateAppServeAppEndpoint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "info.proto",
}

// KeycloakInfoServiceClient is the client API for KeycloakInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeycloakInfoServiceClient interface {
	// CreateKeycloakInfo creates a new keycloak info.
	CreateKeycloakInfo(ctx context.Context, in *CreateKeycloakInfoRequest, opts ...grpc.CallOption) (*IDResponse, error)
	// GetKeycloakInfoByClusterId gets an array of keycloak infos By the clusterID
	GetKeycloakInfoByClusterId(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetKeycloakInfoResponse, error)
	// UpdateKeycloakInfo updates a status of an keycloak info
	UpdateKeycloakInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// DeleteKeycloakInfo deletes an keycloak info.
	DeleteKeycloakInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type keycloakInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeycloakInfoServiceClient(cc grpc.ClientConnInterface) KeycloakInfoServiceClient {
	return &keycloakInfoServiceClient{cc}
}

func (c *keycloakInfoServiceClient) CreateKeycloakInfo(ctx context.Context, in *CreateKeycloakInfoRequest, opts ...grpc.CallOption) (*IDResponse, error) {
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.KeycloakInfoService/CreateKeycloakInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keycloakInfoServiceClient) GetKeycloakInfoByClusterId(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*GetKeycloakInfoResponse, error) {
	out := new(GetKeycloakInfoResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.KeycloakInfoService/GetKeycloakInfoByClusterId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keycloakInfoServiceClient) UpdateKeycloakInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.KeycloakInfoService/UpdateKeycloakInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keycloakInfoServiceClient) DeleteKeycloakInfo(ctx context.Context, in *IDRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, "/tks_pb.KeycloakInfoService/DeleteKeycloakInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeycloakInfoServiceServer is the server API for KeycloakInfoService service.
// All implementations must embed UnimplementedKeycloakInfoServiceServer
// for forward compatibility
type KeycloakInfoServiceServer interface {
	// CreateKeycloakInfo creates a new keycloak info.
	CreateKeycloakInfo(context.Context, *CreateKeycloakInfoRequest) (*IDResponse, error)
	// GetKeycloakInfoByClusterId gets an array of keycloak infos By the clusterID
	GetKeycloakInfoByClusterId(context.Context, *IDRequest) (*GetKeycloakInfoResponse, error)
	// UpdateKeycloakInfo updates a status of an keycloak info
	UpdateKeycloakInfo(context.Context, *IDRequest) (*SimpleResponse, error)
	// DeleteKeycloakInfo deletes an keycloak info.
	DeleteKeycloakInfo(context.Context, *IDRequest) (*SimpleResponse, error)
	mustEmbedUnimplementedKeycloakInfoServiceServer()
}

// UnimplementedKeycloakInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKeycloakInfoServiceServer struct {
}

func (UnimplementedKeycloakInfoServiceServer) CreateKeycloakInfo(context.Context, *CreateKeycloakInfoRequest) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKeycloakInfo not implemented")
}
func (UnimplementedKeycloakInfoServiceServer) GetKeycloakInfoByClusterId(context.Context, *IDRequest) (*GetKeycloakInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeycloakInfoByClusterId not implemented")
}
func (UnimplementedKeycloakInfoServiceServer) UpdateKeycloakInfo(context.Context, *IDRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeycloakInfo not implemented")
}
func (UnimplementedKeycloakInfoServiceServer) DeleteKeycloakInfo(context.Context, *IDRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeycloakInfo not implemented")
}
func (UnimplementedKeycloakInfoServiceServer) mustEmbedUnimplementedKeycloakInfoServiceServer() {}

// UnsafeKeycloakInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeycloakInfoServiceServer will
// result in compilation errors.
type UnsafeKeycloakInfoServiceServer interface {
	mustEmbedUnimplementedKeycloakInfoServiceServer()
}

func RegisterKeycloakInfoServiceServer(s grpc.ServiceRegistrar, srv KeycloakInfoServiceServer) {
	s.RegisterService(&KeycloakInfoService_ServiceDesc, srv)
}

func _KeycloakInfoService_CreateKeycloakInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeycloakInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeycloakInfoServiceServer).CreateKeycloakInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.KeycloakInfoService/CreateKeycloakInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeycloakInfoServiceServer).CreateKeycloakInfo(ctx, req.(*CreateKeycloakInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeycloakInfoService_GetKeycloakInfoByClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeycloakInfoServiceServer).GetKeycloakInfoByClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.KeycloakInfoService/GetKeycloakInfoByClusterId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeycloakInfoServiceServer).GetKeycloakInfoByClusterId(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeycloakInfoService_UpdateKeycloakInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeycloakInfoServiceServer).UpdateKeycloakInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.KeycloakInfoService/UpdateKeycloakInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeycloakInfoServiceServer).UpdateKeycloakInfo(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeycloakInfoService_DeleteKeycloakInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeycloakInfoServiceServer).DeleteKeycloakInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tks_pb.KeycloakInfoService/DeleteKeycloakInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeycloakInfoServiceServer).DeleteKeycloakInfo(ctx, req.(*IDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeycloakInfoService_ServiceDesc is the grpc.ServiceDesc for KeycloakInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeycloakInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tks_pb.KeycloakInfoService",
	HandlerType: (*KeycloakInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKeycloakInfo",
			Handler:    _KeycloakInfoService_CreateKeycloakInfo_Handler,
		},
		{
			MethodName: "GetKeycloakInfoByClusterId",
			Handler:    _KeycloakInfoService_GetKeycloakInfoByClusterId_Handler,
		},
		{
			MethodName: "UpdateKeycloakInfo",
			Handler:    _KeycloakInfoService_UpdateKeycloakInfo_Handler,
		},
		{
			MethodName: "DeleteKeycloakInfo",
			Handler:    _KeycloakInfoService_DeleteKeycloakInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "info.proto",
}
